{"0": {
    "doc": "Context Fallbacks",
    "title": "Context Fallbacks",
    "content": "Context fallbacks let you reuse policies across related execution modes without duplicating rules. When no policy matches a given mode, the engine retries evaluation with a fallback mode. ",
    "url": "/guard/context-fallbacks/",
    
    "relUrl": "/context-fallbacks/"
  },"1": {
    "doc": "Context Fallbacks",
    "title": "The problem",
    "content": "Consider a system with several execution modes: interactive, background, scheduler, bot_processor, realtime. Many of these non-interactive modes should follow the same policies as background, but writing separate rules for each is tedious and error-prone: . # Without fallbacks -- repetitive and fragile policies: - id: deny-bg-high condition: modes: [background] risk: [high] effect: deny - id: deny-scheduler-high # Same logic, different mode condition: modes: [scheduler] risk: [high] effect: deny - id: deny-bot-high # Same logic again condition: modes: [bot_processor] risk: [high] effect: deny . ",
    "url": "/guard/context-fallbacks/#the-problem",
    
    "relUrl": "/context-fallbacks/#the-problem"
  },"2": {
    "doc": "Context Fallbacks",
    "title": "The solution",
    "content": "Declare a context_fallbacks map at the top level. The engine uses it to walk a fallback chain when no policy matches directly: . context_fallbacks: scheduler: background bot_processor: background realtime: background policies: - id: deny-bg-high condition: modes: [background] risk: [high] effect: deny . Now a tool invoked in scheduler mode with high risk will: . | Try to match policies with mode=scheduler. No match. | Look up scheduler in context_fallbacks – finds background. | Retry evaluation with mode=background. Matches deny-bg-high. | Return effect: deny. | . One rule covers background, scheduler, bot_processor, and realtime. ",
    "url": "/guard/context-fallbacks/#the-solution",
    
    "relUrl": "/context-fallbacks/#the-solution"
  },"3": {
    "doc": "Context Fallbacks",
    "title": "Multi-level chains",
    "content": "Fallbacks can chain multiple levels deep: . context_fallbacks: cron: scheduler scheduler: background . A tool in cron mode will try: cron -&gt; scheduler -&gt; background. ",
    "url": "/guard/context-fallbacks/#multi-level-chains",
    
    "relUrl": "/context-fallbacks/#multi-level-chains"
  },"4": {
    "doc": "Context Fallbacks",
    "title": "Cycle detection",
    "content": "The engine detects cycles and stops. If your fallback map contains a -&gt; b -&gt; a, the engine will try a, then b, see that a was already visited, and stop. It then falls through to defaults. # Safe -- the engine handles this gracefully context_fallbacks: a: b b: a . ",
    "url": "/guard/context-fallbacks/#cycle-detection",
    
    "relUrl": "/context-fallbacks/#cycle-detection"
  },"5": {
    "doc": "Context Fallbacks",
    "title": "How it interacts with evaluation",
    "content": "The full evaluation flow: . | Sort policies by priority. | Find the first enabled policy that matches the original context. If found, return its verdict. | If no match, check context_fallbacks for the current mode. | If a fallback exists, replace the mode in the context and re-evaluate (step 2). | Repeat until a match is found, the chain is exhausted, or a cycle is detected. | If still no match, return the defaults. | . Only the mode field changes during fallback. All other context fields (tool, model, risk, user, etc.) remain the same. ",
    "url": "/guard/context-fallbacks/#how-it-interacts-with-evaluation",
    
    "relUrl": "/context-fallbacks/#how-it-interacts-with-evaluation"
  },"6": {
    "doc": "Context Fallbacks",
    "title": "Accessing fallbacks programmatically",
    "content": "All three SDKs expose the loaded fallback map: . Python . engine = PolicyEngine(ps) print(engine.context_fallbacks) # {\"scheduler\": \"background\", \"bot_processor\": \"background\"} . TypeScript . const engine = new PolicyEngine(ps); console.log(engine.contextFallbacks); // { scheduler: \"background\", bot_processor: \"background\" } . Go . engine := guard.NewPolicyEngine(ps) fmt.Println(engine.ContextFallbacks()) // map[scheduler:background bot_processor:background] . ",
    "url": "/guard/context-fallbacks/#accessing-fallbacks-programmatically",
    
    "relUrl": "/context-fallbacks/#accessing-fallbacks-programmatically"
  },"7": {
    "doc": "Context Fallbacks",
    "title": "Common patterns",
    "content": "Non-interactive modes fall back to background . context_fallbacks: scheduler: background bot_processor: background realtime: background . Environment-specific chains . context_fallbacks: staging: production preview: staging . A tool in preview mode inherits staging policies, which in turn inherit production policies. ",
    "url": "/guard/context-fallbacks/#common-patterns",
    
    "relUrl": "/context-fallbacks/#common-patterns"
  },"8": {
    "doc": "Effects",
    "title": "Effects",
    "content": "Effects define what happens when a policy matches. Agent Policy treats effects as extensible strings – you can use any value your runtime knows how to dispatch. allow | deny hitl aitl pitl filter custom Well-known effects are provided as SDK constants. Custom effects are any string your runtime understands. ",
    "url": "/guard/effects/",
    
    "relUrl": "/effects/"
  },"9": {
    "doc": "Effects",
    "title": "Well-known effects",
    "content": "These effects are provided as constants in every SDK and cover the most common agent governance patterns: . | Effect | Constant (Python / TS / Go) | Description | . | allow | Effect.allow / ALLOW / EffectAllow | Auto-approve. The tool runs without any intervention. | . | deny | Effect.deny / DENY / EffectDeny | Block. The tool invocation is rejected. | . | hitl | Effect.hitl / HITL / EffectHITL | Human-in-the-loop. A human must approve before execution. | . | aitl | Effect.aitl / AITL / EffectAITL | AI-in-the-loop. An AI reviewer evaluates the invocation. | . | pitl | Effect.pitl / PITL / EffectPITL | Phone-in-the-loop. Verification via outbound phone call. | . | filter | Effect.filter / FILTER / EffectFilter | Content safety filter. Run a safety check (e.g., Prompt Shield) before execution. | . | ask | Effect.ask / ASK / EffectAsk | Alias for hitl. Provided for backward compatibility. | . ",
    "url": "/guard/effects/#well-known-effects",
    
    "relUrl": "/effects/#well-known-effects"
  },"10": {
    "doc": "Effects",
    "title": "Custom effects",
    "content": "Effects are not limited to the values above. If your system has a verification strategy the well-known effects do not cover, use it directly in YAML: . policies: - id: require-manager-approval priority: 30 condition: risk: [critical] effect: manager-approval - id: require-mfa priority: 25 condition: tools: [deploy-production] effect: mfa-verification - id: audit-only priority: 10 condition: modes: [background] risk: [low] effect: audit-log . The engine returns the effect string as-is. Your runtime dispatches on it: . Python . from agent_policy_guard import PolicyEngine, EvalContext, Effect # Custom effects work through the Effect enum's extensibility verdict = engine.evaluate(EvalContext(tool=\"deploy-production\")) match verdict.effect.value: case \"allow\": execute_tool(ctx) case \"deny\": reject(ctx) case \"hitl\": request_human_approval(ctx) case \"manager-approval\": request_manager_sign_off(ctx) case \"mfa-verification\": trigger_mfa_flow(ctx) case _: raise ValueError(f\"Unknown effect: {verdict.effect.value}\") # Or use resolve() for cleaner dispatch action = engine.resolve(EvalContext(tool=\"deploy-production\")) dispatch_table[action](ctx) . TypeScript . import { PolicyEngine, ALLOW, DENY, HITL } from \"@agent-policy/guard\"; const action = engine.resolve({ tool: \"deploy-production\" }); const handlers: Record&lt;string, (ctx: Context) =&gt; void&gt; = { [ALLOW]: (ctx) =&gt; executeTool(ctx), [DENY]: (ctx) =&gt; reject(ctx), [HITL]: (ctx) =&gt; requestApproval(ctx), \"manager-approval\": (ctx) =&gt; requestManagerSignOff(ctx), \"mfa-verification\": (ctx) =&gt; triggerMfaFlow(ctx), }; handlers[action]?.(ctx) ?? throwUnknownEffect(action); . Go . action := engine.Resolve(guard.EvalContext{Tool: \"deploy-production\"}) switch action { case string(guard.EffectAllow): executeTool(ctx) case string(guard.EffectDeny): reject(ctx) case string(guard.EffectHITL): requestApproval(ctx) case \"manager-approval\": requestManagerSignOff(ctx) default: return fmt.Errorf(\"unknown effect: %s\", action) } . ",
    "url": "/guard/effects/#custom-effects",
    
    "relUrl": "/effects/#custom-effects"
  },"11": {
    "doc": "Effects",
    "title": "The resolve() method",
    "content": "Every SDK provides a resolve() method that returns just the effect as a plain string. This is the recommended way to integrate with systems that dispatch on strings: . | SDK | Method | Returns | . | Python | engine.resolve(ctx) | str (e.g., \"hitl\") | . | TypeScript | engine.resolve(ctx) | string | . | Go | engine.Resolve(ctx) | string | . Use resolve() when you only need the effect. Use evaluate() when you also need the channel, matched policy ID, or want to inspect the full verdict. ",
    "url": "/guard/effects/#the-resolve-method",
    
    "relUrl": "/effects/#the-resolve-method"
  },"12": {
    "doc": "Effects",
    "title": "Design rationale",
    "content": "Effects are strings rather than a fixed enum so that the policy language can evolve alongside your system. If you add a new approval strategy to your runtime next month, you can use it in policy YAML immediately – no library upgrade required. The well-known constants exist for ergonomics and IDE autocompletion, but they are not enforced during evaluation. The engine is intentionally permissive: it evaluates conditions and returns whatever effect string the matched policy declares. ",
    "url": "/guard/effects/#design-rationale",
    
    "relUrl": "/effects/#design-rationale"
  },"13": {
    "doc": "Examples",
    "title": "Example Policy Sets",
    "content": "The repository includes three ready-to-use policy sets in the examples/ directory. Each is designed for a different trust and risk profile. ",
    "url": "/guard/examples/#example-policy-sets",
    
    "relUrl": "/examples/#example-policy-sets"
  },"14": {
    "doc": "Examples",
    "title": "Permissive",
    "content": "File: examples/permissive.yaml . For trusted environments with strong frontier models. Minimal friction – most tools are auto-approved. Only background infrastructure tools and outbound phone calls require additional verification. apiVersion: agent-policy/v1 kind: PolicySet metadata: name: permissive version: \"1.0.0\" labels: tier: \"1\" environment: development defaults: effect: allow channel: chat context_fallbacks: scheduler: background bot_processor: background realtime: background policies: - id: allow-readonly name: Allow read-only tools everywhere priority: 10 condition: tools: [view, grep, glob, list_scheduled_tasks, search_memories_tool] effect: allow - id: hitl-background-infra name: Require approval for background infra tools priority: 50 condition: modes: [background] tools: [\"mcp:github-*\", \"mcp:azure-*\", bash, run] effect: hitl channel: chat - id: phone-verify-voice-calls name: Phone verify outbound voice calls priority: 30 condition: tools: [make_voice_call] effect: pitl channel: phone . What this policy does: . | Scenario | Effect | . | Any read-only tool | allow | . | Interactive bash | allow (default) | . | Background bash | hitl | . | Background mcp:github-issues | hitl | . | make_voice_call | pitl (phone verification) | . | Anything else | allow (default) | . ",
    "url": "/guard/examples/#permissive",
    
    "relUrl": "/examples/#permissive"
  },"15": {
    "doc": "Examples",
    "title": "Balanced",
    "content": "File: examples/balanced.yaml . For standard production deployments. Layered risk-based approach: low risk passes through, medium risk gets filtered or AI-reviewed depending on mode, high risk is denied in background and requires human approval in interactive. apiVersion: agent-policy/v1 kind: PolicySet metadata: name: balanced version: \"1.0.0\" labels: tier: \"2\" environment: production defaults: effect: hitl channel: chat context_fallbacks: scheduler: background bot_processor: background realtime: background policies: - id: allow-low-risk priority: 10 condition: risk: [low] effect: allow - id: filter-interactive-medium priority: 20 condition: modes: [interactive] risk: [medium] effect: filter - id: deny-background-high priority: 30 condition: modes: [background] risk: [high] effect: deny - id: hitl-interactive-high priority: 40 condition: modes: [interactive] risk: [high] effect: hitl channel: chat - id: aitl-background-medium priority: 50 condition: modes: [background] risk: [medium] effect: aitl - id: phone-verify-calls priority: 25 condition: tools: [make_voice_call] effect: pitl channel: phone . What this policy does: . | Scenario | Effect | . | Low risk, any mode | allow | . | Medium risk, interactive | filter (content safety) | . | Medium risk, background | aitl (AI review) | . | High risk, interactive | hitl (human approval) | . | High risk, background | deny | . | make_voice_call | pitl (phone verification) | . | Scheduler, high risk | deny (falls back to background) | . | Anything else | hitl (default) | . ",
    "url": "/guard/examples/#balanced",
    
    "relUrl": "/examples/#balanced"
  },"16": {
    "doc": "Examples",
    "title": "Restrictive",
    "content": "File: examples/restrictive.yaml . For high-security environments or less capable models. Default deny – only explicitly allowed tools pass through. All writes and executions require human approval in interactive mode and are denied in background. apiVersion: agent-policy/v1 kind: PolicySet metadata: name: restrictive version: \"1.0.0\" labels: tier: \"3\" environment: production defaults: effect: deny channel: chat context_fallbacks: scheduler: background bot_processor: background realtime: background policies: - id: allow-readonly priority: 10 condition: tools: [view, grep, glob, list_scheduled_tasks, search_memories_tool] effect: allow - id: allow-low-risk-interactive priority: 15 condition: modes: [interactive] risk: [low] effect: allow - id: deny-background-writes priority: 20 condition: modes: [background] risk: [medium, high] effect: deny - id: phone-verify-calls priority: 25 condition: tools: [make_voice_call] effect: pitl channel: phone - id: hitl-interactive-writes priority: 30 condition: modes: [interactive] tools: [create, edit] effect: hitl - id: hitl-interactive-terminal priority: 35 condition: modes: [interactive] tools: [bash, run] effect: hitl - id: hitl-interactive-mcp priority: 40 condition: modes: [interactive] mcp_servers: [\"*\"] effect: hitl . What this policy does: . | Scenario | Effect | . | Read-only tools | allow | . | Low risk, interactive | allow | . | Medium/high risk, background | deny | . | edit / create, interactive | hitl | . | bash / run, interactive | hitl | . | Any MCP server, interactive | hitl | . | make_voice_call | pitl | . | Anything else | deny (default) | . ",
    "url": "/guard/examples/#restrictive",
    
    "relUrl": "/examples/#restrictive"
  },"17": {
    "doc": "Examples",
    "title": "Choosing a policy set",
    "content": "| Factor | Permissive | Balanced | Restrictive | . | Model trust | High (frontier) | Standard | Low / untrusted | . | Environment | Development | Production | High-security | . | Default effect | allow | hitl | deny | . | Background autonomy | High | Medium | None | . | Approval friction | Low | Medium | High | . Start with balanced for most deployments. Move to permissive once you have confidence in the model and tooling. Use restrictive for sensitive environments or when onboarding a new model. ",
    "url": "/guard/examples/#choosing-a-policy-set",
    
    "relUrl": "/examples/#choosing-a-policy-set"
  },"18": {
    "doc": "Examples",
    "title": "Customizing",
    "content": "These examples are starting points. Fork and adapt: . | Add model-specific rules with models: [gpt-*] conditions. | Scope policies to specific users with users: [admin-*]. | Add your own custom effects for organization-specific approval workflows. | Adjust priorities to change which rules take precedence. | . ",
    "url": "/guard/examples/#customizing",
    
    "relUrl": "/examples/#customizing"
  },"19": {
    "doc": "Examples",
    "title": "Examples",
    "content": " ",
    "url": "/guard/examples/",
    
    "relUrl": "/examples/"
  },"20": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": "Agent Policy is not yet published to any package registry. While the project is under active development, install directly from the Git repository. 1. Write YAML policy.yaml | 2. Load PolicyEngine(ps) | 3. Evaluate resolve(ctx) Available in Python, TypeScript, and Go with identical semantics. ",
    "url": "/guard/getting-started/",
    
    "relUrl": "/getting-started/"
  },"21": {
    "doc": "Getting Started",
    "title": "Prerequisites",
    "content": " ",
    "url": "/guard/getting-started/#prerequisites",
    
    "relUrl": "/getting-started/#prerequisites"
  },"22": {
    "doc": "Getting Started",
    "title": "Installation",
    "content": "Clone the repository: . git clone https://github.com/agent-policy/guard.git cd agent-policy . Python . cd python pip install -e . For development (includes pytest and ruff): . pip install -e \".[dev]\" . TypeScript . cd typescript npm install . To use it as a dependency in another project, reference the local path in your package.json: . { \"dependencies\": { \"@agent-policy/guard\": \"file:../path/to/agent-policy/typescript\" } } . Go . # In your go.mod, use a replace directive pointing to the local clone: # replace github.com/agent-policy/guard =&gt; ../path/to/agent-policy/go go get github.com/agent-policy/guard . ",
    "url": "/guard/getting-started/#installation",
    
    "relUrl": "/getting-started/#installation"
  },"23": {
    "doc": "Getting Started",
    "title": "Write your first policy",
    "content": "Create a file called policy.yaml: . apiVersion: agent-policy/v1 kind: PolicySet metadata: name: my-first-policy defaults: effect: deny policies: - id: allow-readonly name: Allow read-only tools priority: 10 condition: tools: [view, grep, glob] effect: allow - id: approve-writes name: Require approval for write tools priority: 20 condition: modes: [interactive] tools: [edit, create] effect: hitl . This policy: . | Allows read-only tools (view, grep, glob) with no intervention. | Requires human approval for edit and create in interactive mode. | Denies everything else by default. | . ",
    "url": "/guard/getting-started/#write-your-first-policy",
    
    "relUrl": "/getting-started/#write-your-first-policy"
  },"24": {
    "doc": "Getting Started",
    "title": "Evaluate at runtime",
    "content": "Python . from agent_policy_guard import PolicyEngine, EvalContext, load_policy_set ps = load_policy_set(\"policy.yaml\") engine = PolicyEngine(ps) # Read-only tool -&gt; allow v = engine.evaluate(EvalContext(tool=\"view\")) print(v.effect) # Effect.allow print(v.policy_id) # \"allow-readonly\" # Write tool, interactive -&gt; hitl v = engine.evaluate(EvalContext(tool=\"edit\", mode=\"interactive\")) print(v.effect) # Effect.hitl print(v.policy_id) # \"approve-writes\" # Write tool, background -&gt; deny (default) v = engine.evaluate(EvalContext(tool=\"edit\", mode=\"background\")) print(v.effect) # Effect.deny print(v.policy_id) # None # Use resolve() when you just need the effect string action = engine.resolve(EvalContext(tool=\"edit\", mode=\"interactive\")) print(action) # \"hitl\" . TypeScript . import { PolicyEngine, loadPolicySet } from \"@agent-policy/guard\"; const ps = await loadPolicySet(\"policy.yaml\"); const engine = new PolicyEngine(ps); const v = engine.evaluate({ tool: \"view\" }); console.log(v.effect); // \"allow\" console.log(v.policyId); // \"allow-readonly\" const action = engine.resolve({ tool: \"edit\", mode: \"interactive\" }); console.log(action); // \"hitl\" . Go . package main import ( \"fmt\" guard \"github.com/agent-policy/guard\" ) func main() { ps, err := guard.LoadPolicySet(\"policy.yaml\") if err != nil { panic(err) } engine := guard.NewPolicyEngine(ps) v := engine.Evaluate(guard.EvalContext{Tool: \"view\"}) fmt.Println(v.Effect) // allow fmt.Println(v.PolicyID) // allow-readonly action := engine.Resolve(guard.EvalContext{Tool: \"edit\", Mode: \"interactive\"}) fmt.Println(action) // hitl } . ",
    "url": "/guard/getting-started/#evaluate-at-runtime",
    
    "relUrl": "/getting-started/#evaluate-at-runtime"
  },"25": {
    "doc": "Getting Started",
    "title": "Validate with JSON Schema",
    "content": "The repository includes a JSON Schema at spec/schema.json. Use it to validate policy files in CI: . # Using ajv-cli (npm install -g ajv-cli) ajv validate -s spec/schema.json -d policy.yaml # Using check-jsonschema (pip install check-jsonschema) check-jsonschema --schemafile spec/schema.json policy.yaml . ",
    "url": "/guard/getting-started/#validate-with-json-schema",
    
    "relUrl": "/getting-started/#validate-with-json-schema"
  },"26": {
    "doc": "Getting Started",
    "title": "Run the tests",
    "content": "# Python cd python &amp;&amp; pytest tests/ -v # TypeScript cd typescript &amp;&amp; npx vitest run # Go cd go &amp;&amp; go test -v ./... ",
    "url": "/guard/getting-started/#run-the-tests",
    
    "relUrl": "/getting-started/#run-the-tests"
  },"27": {
    "doc": "Getting Started",
    "title": "Next steps",
    "content": ". | Policy Language Reference – full YAML specification | Effects – extensible effect system and well-known values | Context Fallbacks – mode-based fallback chains | Examples – ready-to-use policy sets for common scenarios | . ",
    "url": "/guard/getting-started/#next-steps",
    
    "relUrl": "/getting-started/#next-steps"
  },"28": {
    "doc": "Home",
    "title": "Agent Policy",
    "content": "A declarative policy language for controlling AI agent autonomy. Agent Policy lets teams define guardrails that govern what an AI agent can do, when it needs human approval, and when it should be blocked entirely. Policies are written in YAML, version-controlled alongside code, and evaluated at runtime before every tool invocation. Get Started Policy Language . | | | | Policy YAML | allow deny hitl / aitl / pitl Verdict PolicyEngine ",
    "url": "/guard/#agent-policy",
    
    "relUrl": "/#agent-policy"
  },"29": {
    "doc": "Home",
    "title": "How it works",
    "content": ". | Write a policy – a YAML file that maps tools, execution modes, risk levels, and models to effects like allow, deny, hitl, or filter. | Load the policy into a PolicyEngine in your runtime – available in Python, TypeScript, and Go. | Evaluate before every tool call – the engine returns a verdict (effect + channel + matched policy ID) that your runtime dispatches on. | . apiVersion: agent-policy/v1 kind: PolicySet metadata: name: my-guardrails defaults: effect: hitl policies: - id: allow-readonly priority: 10 condition: tools: [view, grep, glob] effect: allow - id: deny-bg-infra priority: 20 condition: modes: [background] tools: [bash, run, \"mcp:github-*\"] effect: deny . from agent_policy_guard import PolicyEngine, EvalContext, load_policy_set engine = PolicyEngine(load_policy_set(\"policy.yaml\")) action = engine.resolve(EvalContext(tool=\"bash\", mode=\"background\")) # action == \"deny\" . ",
    "url": "/guard/#how-it-works",
    
    "relUrl": "/#how-it-works"
  },"30": {
    "doc": "Home",
    "title": "Key features",
    "content": ". | Extensible effects – allow, deny, hitl, aitl, pitl, filter, or any custom string your runtime understands. | Context fallbacks – map execution modes to fallback modes so policies compose without duplication. | Glob matching – use * and ? patterns in tool names, models, users, and MCP servers. | Priority ordering – lower number wins, first match returns. Predictable, auditable evaluation. | Three SDKs – Python, TypeScript, and Go with identical semantics. Write policies once, evaluate anywhere. | . | JSON Schema – validate policies in CI before they reach production. | . Agent Policy is under active development. The library is not yet published to any package registry (PyPI, npm, or Go modules). Install from source via git clone for now. See Getting Started for details. ",
    "url": "/guard/#key-features",
    
    "relUrl": "/#key-features"
  },"31": {
    "doc": "Home",
    "title": "Home",
    "content": ". ",
    "url": "/guard/",
    
    "relUrl": "/"
  },"32": {
    "doc": "Policy Language",
    "title": "Policy Language Reference",
    "content": "Agent Policy uses a YAML-based policy language inspired by Kubernetes resource definitions. Every policy file is a PolicySet – a collection of ordered rules evaluated against a runtime context. ",
    "url": "/guard/policy-language/#policy-language-reference",
    
    "relUrl": "/policy-language/#policy-language-reference"
  },"33": {
    "doc": "Policy Language",
    "title": "Top-level structure",
    "content": "apiVersion: agent-policy/v1 kind: PolicySet metadata: name: my-policy description: Human-readable description version: \"1.0.0\" labels: environment: production tier: \"2\" defaults: effect: hitl channel: chat context_fallbacks: scheduler: background bot_processor: background policies: - id: rule-1 # ... | Field | Required | Description | . | apiVersion | Yes | Must be agent-policy/v1. | . | kind | Yes | Must be PolicySet. | . | metadata | Yes | Name (required), description, version, and labels. | . | defaults | No | Fallback effect and channel when no policy matches. Defaults to effect: ask, channel: chat. | . | context_fallbacks | No | Map of execution mode to fallback mode. See Context Fallbacks. | . | policies | Yes | Ordered list of policy rules. | . ",
    "url": "/guard/policy-language/#top-level-structure",
    
    "relUrl": "/policy-language/#top-level-structure"
  },"34": {
    "doc": "Policy Language",
    "title": "Metadata",
    "content": "metadata: name: production-guardrails # Required description: &gt; # Optional Guardrails for the production deployment. version: \"2.1.0\" # Optional, semver recommended labels: # Optional key-value pairs environment: production team: platform . Labels are freeform strings. They are stored but not used in evaluation – use them for filtering, documentation, or tooling. ",
    "url": "/guard/policy-language/#metadata",
    
    "relUrl": "/policy-language/#metadata"
  },"35": {
    "doc": "Policy Language",
    "title": "Policy rules",
    "content": "Each policy is evaluated independently. The engine sorts policies by priority (ascending) and returns the first match. policies: - id: allow-readonly name: Allow read-only tools description: Safe tools that cannot modify state enabled: true priority: 10 condition: tools: [view, grep, glob] effect: allow - id: deny-bg-infra name: Deny infrastructure tools in background priority: 20 condition: modes: [background] tools: [\"mcp:github-*\", \"mcp:azure-*\", bash] effect: deny . | Field | Required | Default | Description | . | id | Yes | – | Unique identifier. Kebab-case or snake_case, must match ^[a-z0-9][a-z0-9_-]*$. | . | effect | Yes | – | The action to take. Any string – see Effects. | . | name | No | \"\" | Human-readable name. | . | description | No | \"\" | Explanation of intent. | . | enabled | No | true | Set to false to skip this policy without removing it. | . | priority | No | 100 | Integer 0–9999. Lower number = higher priority. | . | condition | No | match-all | Criteria that must match for this policy to fire. Omit to match everything. | . | channel | No | chat | Approval channel override: chat or phone. | . ",
    "url": "/guard/policy-language/#policy-rules",
    
    "relUrl": "/policy-language/#policy-rules"
  },"36": {
    "doc": "Policy Language",
    "title": "Conditions",
    "content": "Conditions define when a policy fires. All specified fields must match (AND logic across fields). Each field’s list uses OR logic – at least one value must match. condition: modes: [interactive, voice] tools: [\"mcp:github-*\", bash] risk: [high, critical] . Condition fields use AND across fields, OR within each field's list modes interactive OR voice AND tools bash OR mcp:github-* AND risk high OR critical | all match fire policy Omitting a field means \"match any value\" for that dimension. This condition matches when: (mode is interactive OR voice) AND (tool matches mcp:github-* OR bash) AND (risk is high OR critical). | Field | Description | Example values | . | modes | Execution mode | interactive, background, voice, api | . | models | Model name (glob) | gpt-*, claude-sonnet-*, o3-* | . | channels | Communication channel | web, teams, telegram, slack, voice | . | tools | Tool name (glob) | bash, mcp:github-*, skill:web-* | . | mcp_servers | MCP server name (glob) | github-mcp-server, azure-* | . | risk | Risk level | low, medium, high, critical | . | users | User ID (glob) | admin-*, user-12345 | . | sessions | Session ID (glob) | sess-prod-* | . Omitting a field means “match any value” for that dimension. Glob patterns . String fields support glob-style patterns: . | Pattern | Matches | . | * | Everything | . | mcp:github-* | mcp:github-issues, mcp:github-pulls, etc. | . | gpt-? | gpt-4, gpt-5, but not gpt-4o | . | bash | Exact match: bash only | . ",
    "url": "/guard/policy-language/#conditions",
    
    "relUrl": "/policy-language/#conditions"
  },"37": {
    "doc": "Policy Language",
    "title": "Evaluation logic",
    "content": ". | Policies are sorted by priority (ascending). | Disabled policies (enabled: false) are skipped. | The first enabled policy whose condition matches the context returns its effect, channel, and policy ID as a verdict. | If no policy matches and a context_fallback exists for the current mode, the engine retries with the fallback mode. See Context Fallbacks. | If nothing matches after all fallbacks, the defaults apply. | . The evaluation is deterministic: same policy set + same context = same verdict. ",
    "url": "/guard/policy-language/#evaluation-logic",
    
    "relUrl": "/policy-language/#evaluation-logic"
  },"38": {
    "doc": "Policy Language",
    "title": "Defaults",
    "content": "defaults: effect: hitl channel: chat . When no policy matches (including after fallback), the engine returns a verdict with the default effect and channel. If defaults is omitted, the engine defaults to effect: ask, channel: chat. ",
    "url": "/guard/policy-language/#defaults",
    
    "relUrl": "/policy-language/#defaults"
  },"39": {
    "doc": "Policy Language",
    "title": "Putting it together",
    "content": "A complete policy file: . apiVersion: agent-policy/v1 kind: PolicySet metadata: name: production version: \"1.0.0\" defaults: effect: hitl channel: chat context_fallbacks: scheduler: background bot_processor: background policies: - id: allow-readonly priority: 10 condition: tools: [view, grep, glob] effect: allow - id: filter-medium-interactive priority: 20 condition: modes: [interactive] risk: [medium] effect: filter - id: aitl-medium-background priority: 30 condition: modes: [background] risk: [medium] effect: aitl - id: deny-high-background priority: 40 condition: modes: [background] risk: [high] effect: deny - id: phone-verify-calls priority: 15 condition: tools: [make_voice_call] effect: pitl channel: phone . ",
    "url": "/guard/policy-language/#putting-it-together",
    
    "relUrl": "/policy-language/#putting-it-together"
  },"40": {
    "doc": "Policy Language",
    "title": "Policy Language",
    "content": " ",
    "url": "/guard/policy-language/",
    
    "relUrl": "/policy-language/"
  },"41": {
    "doc": "SDK Reference",
    "title": "SDK Reference",
    "content": "Agent Policy ships identical evaluation semantics in Python, TypeScript, and Go. This page covers the API surface of each SDK. ",
    "url": "/guard/sdk-reference/",
    
    "relUrl": "/sdk-reference/"
  },"42": {
    "doc": "SDK Reference",
    "title": "Core types",
    "content": "All three SDKs share the same conceptual types: . | Concept | Python | TypeScript | Go | . | Policy set | PolicySet | PolicySet | PolicySet | . | Single rule | Policy | Policy | Policy | . | Condition | Condition | Condition | Condition | . | Evaluation context | EvalContext | EvalContext | EvalContext | . | Result | Verdict | Verdict | Verdict | . | Engine | PolicyEngine | PolicyEngine | PolicyEngine | . ",
    "url": "/guard/sdk-reference/#core-types",
    
    "relUrl": "/sdk-reference/#core-types"
  },"43": {
    "doc": "SDK Reference",
    "title": "Python",
    "content": "Package: agent_policy_guard . Loading . from agent_policy_guard import load_policy_set, load_policy_set_from_str # From file ps = load_policy_set(\"policies.yaml\") # From string ps = load_policy_set_from_str(yaml_string) . Engine . from agent_policy_guard import PolicyEngine, EvalContext engine = PolicyEngine(ps) # Full verdict verdict = engine.evaluate(EvalContext( tool=\"bash\", mode=\"background\", model=\"gpt-4o\", risk=\"high\", channel=\"web\", mcp_server=\"github-mcp-server\", user=\"user-123\", session=\"sess-abc\", )) verdict.effect # Effect enum member (e.g., Effect.deny) verdict.effect.value # Plain string (e.g., \"deny\") verdict.channel # Channel enum member verdict.policy_id # Matched policy ID or None # Effect string only action = engine.resolve(EvalContext(tool=\"bash\", mode=\"background\")) # Returns: \"deny\" # Debug: evaluate all policies results = engine.evaluate_all(EvalContext(tool=\"bash\")) # Returns: [{\"policy_id\": \"...\", \"matched\": True/False, ...}, ...] . Properties . engine.policies # list[Policy] sorted by priority engine.defaults # Defaults (effect, channel) engine.context_fallbacks # dict[str, str] . EvalContext fields . All fields are optional strings. Omit fields you do not have at evaluation time. | Field | Description | . | tool | Tool name being invoked | . | mode | Execution mode (interactive, background, etc.) | . | model | Model identifier | . | risk | Risk level (low, medium, high, critical) | . | channel | Communication channel (input channel, not approval channel) | . | mcp_server | MCP server name | . | user | User identifier | . | session | Session identifier | . ",
    "url": "/guard/sdk-reference/#python",
    
    "relUrl": "/sdk-reference/#python"
  },"44": {
    "doc": "SDK Reference",
    "title": "TypeScript",
    "content": "Package: @agent-policy/guard . Loading . import { loadPolicySet, loadPolicySetFromString } from \"@agent-policy/guard\"; // From file const ps = await loadPolicySet(\"policies.yaml\"); // From string const ps = loadPolicySetFromString(yamlString); . Engine . import { PolicyEngine, ALLOW, DENY, HITL, AITL, PITL, FILTER, ASK, } from \"@agent-policy/guard\"; const engine = new PolicyEngine(ps); // Full verdict const verdict = engine.evaluate({ tool: \"bash\", mode: \"background\", model: \"gpt-4o\", risk: \"high\", channel: \"web\", mcpServer: \"github-mcp-server\", user: \"user-123\", session: \"sess-abc\", }); verdict.effect; // string (e.g., \"deny\") verdict.channel; // string (e.g., \"chat\") verdict.policyId; // string or null // Effect string only const action = engine.resolve({ tool: \"bash\", mode: \"background\" }); // Returns: \"deny\" // Debug: evaluate all policies const results = engine.evaluateAll({ tool: \"bash\" }); . Properties . engine.policies; // Policy[] engine.defaults; // Defaults engine.contextFallbacks; // Record&lt;string, string&gt; . Effect constants . import { ALLOW, DENY, HITL, AITL, PITL, FILTER, ASK } from \"@agent-policy/guard\"; . ",
    "url": "/guard/sdk-reference/#typescript",
    
    "relUrl": "/sdk-reference/#typescript"
  },"45": {
    "doc": "SDK Reference",
    "title": "Go",
    "content": "Package: github.com/agent-policy/guard . Loading . import guard \"github.com/agent-policy/guard\" // From file ps, err := guard.LoadPolicySet(\"policies.yaml\") // From bytes ps, err := guard.LoadPolicySetFromBytes(data) . Engine . engine := guard.NewPolicyEngine(ps) // Full verdict v := engine.Evaluate(guard.EvalContext{ Tool: \"bash\", Mode: \"background\", Model: \"gpt-4o\", Risk: \"high\", Channel: \"web\", McpServer: \"github-mcp-server\", User: \"user-123\", Session: \"sess-abc\", }) v.Effect // guard.Effect (e.g., guard.EffectDeny) v.Channel // string v.PolicyID // string (empty if default) // Effect string only action := engine.Resolve(guard.EvalContext{Tool: \"bash\", Mode: \"background\"}) // Returns: \"deny\" // Debug: evaluate all policies results := engine.EvaluateAll(guard.EvalContext{Tool: \"bash\"}) . Properties . engine.Policies() // []Policy engine.Defaults() // Defaults engine.ContextFallbacks() // map[string]string . Effect constants . guard.EffectAllow // \"allow\" guard.EffectDeny // \"deny\" guard.EffectAsk // \"ask\" guard.EffectHITL // \"hitl\" guard.EffectAITL // \"aitl\" guard.EffectPITL // \"pitl\" guard.EffectFilter // \"filter\" . ",
    "url": "/guard/sdk-reference/#go",
    
    "relUrl": "/sdk-reference/#go"
  },"46": {
    "doc": "SDK Reference",
    "title": "JSON Schema validation",
    "content": "Validate policy files against the schema at spec/schema.json: . # ajv-cli ajv validate -s spec/schema.json -d policy.yaml # check-jsonschema check-jsonschema --schemafile spec/schema.json policy.yaml . The schema enforces structure (required fields, types, patterns) but does not restrict effect values – any string is valid. ",
    "url": "/guard/sdk-reference/#json-schema-validation",
    
    "relUrl": "/sdk-reference/#json-schema-validation"
  },"47": {
    "doc": "SDK Reference",
    "title": "Semantic guarantees",
    "content": "All three SDKs guarantee: . | Deterministic evaluation – same policy set + same context = same verdict. | Priority ordering – policies evaluated in ascending priority order. | First match wins – the first matching enabled policy ends evaluation. | Context fallback chain – walked in order with cycle detection. | Effect passthrough – any string effect in YAML is returned as-is. | . ",
    "url": "/guard/sdk-reference/#semantic-guarantees",
    
    "relUrl": "/sdk-reference/#semantic-guarantees"
  }
}
